# 数据库锁
## 按对数据操作的类型(读/写)分
读锁(共享锁):针对同一份数据，多个读操作可以同时进行而不会互相影响

写锁（排它锁）:当前写操作没有完成前，它会阻断其他写锁和读锁

## 按对数据操作的粒度分：
表锁(偏读)：
开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。

行锁(偏写)：
开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

页面锁：
开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般

## 表锁操作
### 【手动增加表锁】
lock table表名字 read(write)，表名字2 read(write)，其它;
### 【查看表上加过的锁】
 show open tables;
### 解锁：
unlock tables;

## 表锁
### 表锁分为
1）共享读锁 自己可读不可干其他的 别人可读不可阻塞其他

2）独占写锁 自己可写不可干其他，别人啥也得阻塞

 **简而言之：读锁会阻塞写，不会阻塞读，写锁会阻塞读和写**

### 分析表锁定：show status like 'table_locks%';
#### 主要参数：
**Table_locks_immediate:产生表级锁定的次数，表示可以立即获取锁的查询次数，每立即获取锁值加1;**

**Table_locks_waited:出现表级锁定争用而发生等待的次数(不能立即获取锁的次数，每等待一次锁值加1)，此值高则说明存在着较严重的表级锁争用情况;**

## 行锁：	
**注意:**
1.sql索引失效会引起行锁升级为表锁  2. 间隙锁
### 【什么是间隙锁】
当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁;对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁)
### 【间隙锁危害】
因为Query执行过程中通过过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值并不存在。
间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害

### 如何锁定一行
**select ........ for update 锁定某一行后，其它的操作会被阻塞，直到锁定行的会话提交commit**

## 分析行锁定：show status like 'innodb_row_lock%';
### 参数
Innodb_row_lock_current_waits:当前正在等待锁定的数量;

***Innodb_row_lock_time:从系统启动到现在锁定总时间长度;**

***Innodb_row_lock_time_avg:每次等待所花平均时间;**

Innodb_row_lock_time_max:从系统启动到现在等待最常的一次所花的时间;

***Innodb_row_lock_waits:系统启动后到现在总共等待的次数;**
## 行锁优化建议：
 尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁。合理设计索引，尽量缩小锁的范围。尽可能较少检索条件，避免间隙锁。尽量控制事务大小，减少锁定资源量和时间长度。尽可能低级别事务隔离
